# Components

## Account
XSOAR account that represents a tenant

## Host
Single server within a multi-tenant deployment
### Single Host
To configure a host (outside an HA Group) do the following:
- GET /host/download
- SCP installer to host server (address and keyfile provided in TF config)
- Via ssh execute the installer, including `-- -y` flag and elastic settings
- Once the installer completes the host will automatically connect to the main host and is viewable from the main api

### HA Group Host
Each HA Group is identified by an {id}. To configure a host do the following:
- GET /host/download/{id}
- SCP installer to host server (address and keyfile provided in TF config)
- Via ssh execute the installer, including `-- -y` flag
- Once the installer completes the host will automatically join the ha group and is viewable from the main api

## HA Group
Group of hosts that provide redundancy to each other.

### Building
- POST /ha-group/create
- Response contains an {id}
- POST /host/build/{id}
- This will take some time to return, should be done asynchronously 
- Once a 200 is returned the installer can be obtained

## Integration Instance
Instance of an integration within an account that is configured.

### Approximate Approach
- POST to `/settings/integration/search`
- grab the `configurations` key
- search for the config that matches the name of the integration
- grab `configuration` array from returned object
```python
module_configuration = configuration["configuration"]
```
- create base module instance config
```python
module_instance = {
    'brand': configuration['name'],
    'category': configuration['category'],
    'configuration': configuration,
    'data': [],
    'enabled': "true",
    'engine': '',
    'id': '',
    'isIntegrationScript': is_byoi,
    'name': instance_name,
    'passwordProtected': False,
    'version': 0
}
```
- iterate through the module configuration options
- parse keys and values of config and add the values to the `module_instance`
- assign defaults as needed
- append the parameter to the `module_instance['data']` array
- send `module_instance` to `/settings/integration` as a PUT request

## Main Host
Like a host, but main. This will be trickier to manage and will require some refactor of the provider (probably). The key difference is the provider cannot rely on the presence of an API key and the initial admin password must be set by the plugin. Also, the provider currently creates a client object that references the url of the/a main host. If this provider begins to manage main hosts as well, there can be no a priori client until after the creation of a resource. It may be possible to get around this by creating a client object in each CRUD function. This shouldn't cause any race conditions or conflicts of any kind as the API is restful and dependencies are tracked by terraform. The real issue with this is that each resource other than main host will need to reference a main host URL to point the client at or put the url in the provider config and create explicit dependencies between the main hosts and other resources. Philosophically this becomes trickier to justify since we're quickly moving away from the provider managing an API and actually managing a full application. So yeah, I don't think we'll be managing main hosts. The main host is the API and should fall outside the scope of this plugin. As an assist to the community I can provide examples of how to create the main hosts in AWS using terraform, likely with the remote exec provisioner.

So have given it some thought and here's where I'm at. The provider config requires two items in particular, the url for the API and the API key. One of the drawbacks/limitations of terraform providers is they can't utilize any unknown values from resources (can you known values the resource utilizes in the config however). I think the XSOAR API also allows for the creation of an API key that is specified by the user (not randomly generated by the server). Confirmed. So what we can do is to set the API key in the provider and specify the hostname of the main host or LB endpoint for the main host group. This will have to be specified/known beforehand but that shouldn't be too bad considering it can be created as a DNS entry or LB rule and the instance IP assigned to them. When creating the main hosts the default admin password will need to be set and the api key created. This will require setting a password to change the default to. There could be potential in having this randomly generated and then saved in the state as a computed attribute (maybe?). But ideally the user will want to set it themselves, so they can use it. This will all still require the underlying infrastructure to be in place.

Gonna give this a whirl. Will definitely be a bit of a refactor.

# Single Tenant vs Multi-tenant
In single tenant there is only a single "account" concept, which doesn't utilize the typical MT url prefix. HA is still available for single tenant though, meaning there are multiple "main" hosts that connect to an elastic backend (and share a NFS volume, but that is an infrastructure implementation detail). 

This is similar for the MT deployment with the main host in HA configuration; multiple hosts, same elastic backend, and a shared NFS volume.